import random
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as ss

def generateMixturePoints(mixture, mixtureProbs, nPoints):
    points = np.zeros((nPoints, 1))
    for i in range(0, nPoints):
        thisComp = np.random.choice(mixture, p=mixtureProbs)
        points[i] = np.random.normal(thisComp["mean"], thisComp["cov"])
    return points

def plotTrueMixture(mixture, mixtureProbs, points):
    xs = np.linspace(points.min(), points.max(), 200)
    ys = np.zeros_like(xs)

    for comp, w in zip(mixture, mixtureProbs):
        mean = comp["mean"]
        cov = comp["cov"]
        ys += ss.norm.pdf(xs, loc=mean, scale=cov) * w

    plt.plot(xs, ys)
    plt.hist(points,density=True,bins=100)
    plt.xlabel("x")
    plt.ylabel("f(x)")
    plt.legend(["True Mixture", "Generated Points"])
    plt.title("Samples generated by Gaussian Mixture=\n0.3 N(0,1) + 0.5 N(10,1) + 0.2 N(3,0.5)")
    # plt.savefig("GaussianMixture.png")
    plt.show()

def createGMPlot():
    mixture = [{"mean": 0, "cov": 1}, {"mean": 10, "cov": 1}, {"mean": 3, "cov": 0.5}]
    probs = [0.3, 0.5, 0.2]
    points = generateMixturePoints(mixture, probs, 1000)
    plotTrueMixture(mixture, probs, points)
    return points

def s(x,t,theta):
    return x*t*theta
def sPrime(x,t,theta):
    return t*theta

def learnNaiveScoreFunction(points,T):
    # init theta = 0
    theta = 0.1
    # learningRate
    eta = 0.01
    for i in range(1000):
        print(theta)
        thisPoint = points[0][0]
        thisT = random.sample(range(0, T), 1)[0]
        theta = theta - eta * (theta * thisPoint**2 + theta)
    return theta




if __name__ == "__main__":
    thisPoints = createGMPlot()
    # print(thisPoints)
    theta_learned = learnNaiveScoreFunction(thisPoints, 10)
    print(theta_learned)
